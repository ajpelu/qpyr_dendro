---
title: "dendro"
author: "AJ Perez-Luque (@ajpelu)"
date: "2017 Feb"
output:  
  md_document:
    variant: markdown_github
bibliography: references.bib 
csl: ecology.csl
---

```{r, warning=FALSE, message=FALSE}
library("tidyverse")
library("dplR")
```


# Read data 
```{r, echo=FALSE}
machine <- 'ajpelu'
# machine <- 'ajpeluLap'
di <- paste('/Users/', machine, '/Dropbox/phd/phd_repos/qpyr_dendro/', sep='')

# sj 
sj <- read.rwl(fname=paste0(di, '/data/SNA_sanjuan.rwl'), format="tucson")
sjt <- read.rwl(fname=paste0(di, '/data/sj_test.rwl'), format="tucson")
```

Algunos árboles tienen 3 cores. Sin embargo, no los tres cores llegan hasta la corteza, por lo tanto, no podemos utilizar el diametro para estimar bai. Vamos a realizar lo siguiente: 

* Crear dos datasets: 
    * Dataset con series de datos que llegan hasta corteza (`sj_cor`)
    * Dataset con series de datos que no llegan hasta corteza (`sj_sin`): se trata de cores que no llegan hasta la corteza. 
    
* Para el cálculo del BAI, en el dataset `sj` utilizamos el diámetro medido en campo. En el caso del dataset `sj_sin` utilizamos la suma de todos los diámetros (:red_circle: `$TODO$ ASK to Guillermo`)

```{r}
# Get summary ring-width series
sj_summ <- summary(sj)

# Get names cores with last year different to 2016 
id_cores_no_bark <- sj_summ %>% 
  filter(last != 2016) %>% select(series) %>% mutate(series = factor(series)) 

id_cores_no_bark <- unname(unlist(id_cores_no_bark))

# Subbet datasets 
sj_cor <- sj[which(! colnames(sj) %in% (id_cores_no_bark))]
sj_sin <- sj[which(colnames(sj) %in% (id_cores_no_bark))]
```


Lectura y preparación de datos de diámetro

```{r}
compete <- read.csv(file=paste0(di, '/data_raw/dendro_competence.csv'), header=TRUE, sep=',')

# Compute diameter (mm)
compete <- compete %>% 
  mutate(dn_mm = (perim_mm / pi))
         
# Get only focal trees, and only selected variables 
ft <- compete %>% 
  filter(sp=='Focal') %>% 
  filter(id_focal!='Fresno') %>% 
  select(id_focal, loc, dn_mm, height_cm)

# Select only SJ trees and 
ft_sj <- ft %>% filter(loc=='SJ')


# get Create a dataframe with core ID
cores <- data.frame(id_cores=colnames(sj))

# Extract replicate and Tree ID from core ID 
cores <- cores %>% 
  mutate(id_focal = as.factor(stringr::str_sub(id_cores, 3,5)),
         id_replica = stringr::str_sub(id_cores, 6,8))

# Create df with diameter and height for each core ID 
diam_cores <- cores %>% inner_join(ft_sj, by='id_focal') %>% 
  select(id_cores, dn_mm)

# remove diamm of cores without bark 
diam_cores_sj <- diam_cores %>% filter(! id_cores %in% id_cores_no_bark)
```

## Cómputo del BAI 


He construido una funcion para el computo del BAI, teniendo en cuenta la aproximación de [@Piovesan2008]


```{r} 
## BAI Function Piovesan 

i <- "SNA0101"

bai_piovesan <- function(rwdf, diam_df){
  # rwdf: a ringwidth dataframe. row: years; col: id_cores
  # diam_df: a dataframe with diameter and id_core (two columns) 
  
  # Output 
  bai <- rwdf 
  
  # length years in Ring-width Data frame 
  vec_ly <- seq_len(nrow(rwdf))

  # ID cores 
  cores <- colnames(rwdf)
  
  for (i in cores){ 
    # 1 # Select core 
    id_core <- i 
    
    # 2 # Select serie 
    rs <- rwdf[[id_core]]
    
    # 3 # Select diameter 
    dbh <- subset(diam_df, id_cores == id_core)
    dbh <- dbh[,2]
    
    # 4 # Prepare data to compute bai 
    #### Omit NA 
    rsomit <- na.omit(rs)
    
    #### Revert w 
    rs_rev <- rev(rsomit)
    
    # Cumsum rever w
    # cum_rs_rev <- cumsum(rs_rev)
    cum_rs_rev <- c(0, cumsum(rs_rev))
    
    # Compute d_{t} 
    d <- dbh - 2*cum_rs_rev
    
    # Remove last element 
    d <- d[-length(d)]
    
    # Bai
    b <- rev((pi/4) * ((d)^2 - (d - 2*rs_rev)^2))
 
    # Store BAI and NA 
    ### Which elements are NA? 
    na <- attributes(rsomit)$na.action
    ### Which ones no? 
    no_na <- vec_ly[!vec_ly %in% na]
    ### Put bai in those element with no NA
    bai[no_na, i] <- b 
  }
  bai 
}




# Test 
b_test_piovesan <- bai_piovesan(rwdf = sj_cor, diam_df = diam_cores_sj)
b_test_dplR <- bai.out(rwl = sj_cor, diam = diam_cores_sj)



```



```{r, eval=FALSE, echo=FALSE}
# BAI dplR
baisj <- bai.out(rwl = sj_cor, diam = diam_cores_sj)

baisjt <- bai.out(rwl = sjt)


# Function to compute BAI (Piovesan et al)

# rwl_file
myrwl <- sj_cor
# Diameter df  
diam_df <- diam_cores_sj

# Core
id_core <- 'SNA0101'  

# Ring-width serie
myrwl_serie <- myrwl[[id_core]]

# Diameter for core id_core 
dbh <- subset(diam_df, id_cores == id_core)
dbh <- dbh[,2]



myrwl_serie2 <- na.omit(myrwl_serie)
cum



r0 <- dbh/2 - c(0,cumsum(rev(myrwl_serie2)))



bai <- (pi/4)*(dbh^2 - ((dbh - 2*myrwl_serie)^2)) 

s <- myrwl_serie[94:96]

d <- sum(s)*2


rev(s)







# Extract rwl serie 
myrwl_i <- myrwl[[1]]


diam_df_i <- diam_cores_sj[1]




# Remove NA 
myrwl_io <- na.omit(myrwl_i)

bai <- 
diam.vec <- diam[, 2]









########## test Piovesan
# rwl_file
myrwl <- baisj

#id_core


# Extract rwl serie 
myrwl_i <- myrwl[[1]]


dbh <- 372.4226





# Year
n.vec <- seq_len(nrow(myrwl))

# Series
seq_len(ncol(myrwl))

# Select a ring-width series
dat <- myrwl[[1]] 
# Remove NA
dat2 <- na.omit(dat)


ggplot(s1, aes(y=SNA0101, x=row.names(s1))) + 
  geom_point() + 
  geom_line(b1, aes(y=SNA0101, x=row.names(b1)))

ggplot(s1, aes(y=SNA0101, x=row.names(b1), group=1)) + geom_line()


```


