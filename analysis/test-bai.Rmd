---
title: "dendro"
author: "AJ Perez-Luque (@ajpelu)"
date: "2017 Feb"
output:  
  md_document:
    variant: markdown_github
bibliography: references.bib 
csl: ecology.csl
---

```{r, warning=FALSE, message=FALSE}
library("tidyverse")
library("stringr")
library("dplR")
library("knitr")
# library("detrendeR")
library("pander")
source(paste0(getwd(), '/script/R/bai_piovesan.R'))
source(paste0(getwd(), '/script/R/rw_byTree.R'))
```

# Read y Prepare data 
* Leer datos `rwl` de SJ y CA
* Leer datos de diametros de los focal tree

```{r, echo=FALSE}
# machine <- 'ajpelu'
machine <- 'ajpeluLap'
di <- paste0('/Users/', machine, '/Dropbox/phd/phd_repos/qpyr_dendro/', sep='')

# sj 
sj <- read.rwl(fname=paste0(di, '/data_raw/dendro_ring/sn_sanjuan/sn_sanjuan.rwl'), format="tucson")

# canar 
ca <- read.rwl(fname=paste0(di, '/data_raw/dendro_ring/sn_canar/sn_canar.rwl'), format="tucson")

# Read diameters data
compete <- read.csv(file=paste0(di, '/data_raw/dendro_competence.csv'), header=TRUE, sep=',')
```

* Crear dataframes `rwl` por cada sitio CA_High, CA_Low, SJ_High. SJ_Low (:red_circle: mejorar la forma de hacerlo)
    * :red_circle: ojo he cambiado los nombres de las series en SJ y en CA
    
```{r}
# Replace SNA by SJ and SNB by CA
names(ca) <- stringr::str_replace(names(ca), "SNB", "CA") 
names(sj) <- stringr::str_replace(names(sj), "SNA", "SJ")

# Remove g in name of some cores of CA. 
names(ca) <- stringr::str_replace(names(ca), "g", "")
```

```{r}
# Create subset to compare between sites 
caL <- ca[,c("CA0101","CA0102","CA0201","CA0202","CA0301","CA0302","CA0401","CA0402","CA0501","CA0502",
             "CA0601","CA0602","CA0701","CA0702","CA0801","CA0802","CA0901","CA0902","CA1001","CA1002",
             "CA2601","CA2602","CA2701","CA2702","CA2801","CA2802","CA2901","CA2902","CA3001","CA3002")] 
caH <- ca[, c("CA1101","CA1102","CA1201","CA1202","CA1301","CA1302","CA1401","CA1402","CA1501","CA1502",
              "CA1601","CA1602","CA1701","CA1702","CA1801","CA1802","CA1901","CA1902","CA2001","CA2002",
              "CA2101","CA2102","CA2201","CA2202","CA2301","CA2302","CA2401","CA2402","CA2501","CA2502")]

sjL <- sj[, c("SJ0101","SJ0102","SJ0201","SJ0202","SJ0301","SJ0302","SJ0401","SJ0402","SJ0501","SJ0502",
              "SJ0601","SJ0602","SJ0603","SJ0701","SJ0702","SJ0801","SJ0802","SJ0901","SJ0902","SJ0903",
              "SJ1001","SJ1002","SJ1003")]
sjH <- sj[, c("SJ1101","SJ1102","SJ1103","SJ1201","SJ1202","SJ1203","SJ1301","SJ1302","SJ1303","SJ1401",
              "SJ1402","SJ1501","SJ1502","SJ1601","SJ1602","SJ1701","SJ1702","SJ1703","SJ1801","SJ1802",
              "SJ1901","SJ1902","SJ2001","SJ2003","SJ2002")]
```


* Lectura y preparación de datos de diámetro

```{r} 
# Prepare Diameter data 

# Compute diameter (mm)
compete <- compete %>% 
  mutate(dn_mm = (perim_mm / pi))

# Change name focal according to loc
compete <- compete %>% 
  mutate(id_focalLoc = stringr::str_replace_all(id_focal, c("A" = "SJ", "B" = "CA")))

         
# Get only focal trees, and only selected variables 
ft <- compete %>% 
  filter(sp=='Focal') %>% 
  filter(id_focal!='Fresno') %>% 
  dplyr::select(id_focal, id_focalLoc, loc, dn_mm, height_cm) 

# Set levels of eleveation 
sj_lowcode  <- paste0('SJ', str_pad(1:10, 2, pad='0'))
sj_highcode <- paste0('SJ', 11:20)
ca_lowcode <- c(paste0('CA', str_pad(1:10, 2, pad='0')),
            paste0('CA', 26:30))
ca_highcode <- paste0('CA', 11:25)

ft <- ft %>% 
  mutate(elev = as.factor(
    ifelse(id_focalLoc %in% sj_lowcode, 'Low',
                       ifelse(id_focalLoc %in% sj_highcode, 'High',
                              ifelse(id_focalLoc %in% ca_lowcode, 'Low', 'High'))))) %>%
  mutate(site = as.factor(paste0(loc, '_', elev)))
```

* Crear dataframes `rwl` por cada sitio CA_High, CA_Low, SJ_High. SJ_Low (:red_circle: mejorar la forma de hacerlo)
    * :red_circle: ojo he cambiado los nombres de las series en SJ y en CA
    
# Summary dendrochronology statistics

* Por cada loc (ca/sj) o site (ca_high, ca_low, sj_high, sj_low) calculamos los siguientes datos: 
    * age: mean + sd (average of all series)
    * year: min, max of all series
    * year range
    * autocorrelation order 1 (ar1): mean + sd 
    * seires intercorrelation (icor): mean + sd 
    
## By site 
```{r}
objects_rwl <- c('caL','caH','sjL','sjH')

out <- c() 

for (i in objects_rwl){ 
  
  aux <- get(i)
  # Stats of singles RWL
  aux_stats <- rwl.stats(aux)
  # Add site 
  aux_stats$site <- as.factor(i)
  
  # Compute interseries correlation 
  aux_stats$interser_cor_val  <- interseries.cor(aux)$res.cor
  aux_stats$interser_cor_p  <- interseries.cor(aux)$p.val
  
  out <- rbind(out, aux_stats)
  }


rwl_by_site <- out %>% group_by(site) %>% 
  summarize(age_mean = round(mean(year),2), 
            age_sd = round(sd(year), 2),
            year_min = min(first),
            year_max = max(last), 
            year_range = year_max - year_min + 1, 
            ar1_mean = round(mean(ar1), 3),
            ar1_sd = round(sd(ar1), 3),
            icor_mean = round(mean(interser_cor_val), 3),
            icor_sd = round(sd(interser_cor_val), 3)) %>% 
  as.data.frame() 

rwl_by_site %>% 
  write.csv(file=paste(di, "data/proto_tables/site_dendro.csv", sep=""), row.names = FALSE)

pander(rwl_by_site, caption='Dendrochronological summary by sites') 
```

## By Loc
```{r}
objects_rwl <- c('ca','sj')

out <- c() 

for (i in objects_rwl){ 
  
  aux <- get(i)
  # Stats of singles RWL
  aux_stats <- rwl.stats(aux)
  # Add site 
  aux_stats$loc <- as.factor(i)
  
  # Compute interseries correlation 
  aux_stats$interser_cor_val  <- interseries.cor(aux)$res.cor
  aux_stats$interser_cor_p  <- interseries.cor(aux)$p.val
  
  out <- rbind(out, aux_stats)
  }


rwl_by_loc <- out %>% group_by(loc) %>% 
  summarize(age_mean = round(mean(year),2), 
            age_sd = round(sd(year), 2),
            year_min = min(first),
            year_max = max(last), 
            year_range = year_max - year_min + 1, 
            ar1_mean = round(mean(ar1), 3),
            ar1_sd = round(sd(ar1), 3),
            icor_mean = round(mean(interser_cor_val), 3),
            icor_sd = round(sd(interser_cor_val), 3)) %>% 
  as.data.frame() 

rwl_by_loc %>% 
  write.csv(file=paste(di, "data/proto_tables/loc_dendro.csv", sep=""), row.names = FALSE)

pander(rwl_by_loc, caption='Dendrochronological summary by sites') 
```


# Aggregate RW by tree 

* Agregar valores medios de RW por loc (obtenemos sj_tree / ca_tree) o por site (sjL_tree, sjH_tree / caL_tree, caH_tree) 
* ver fun rw_byTree o utilizar treeMean (dplR)

```{r}
# Remember snc = structure of core name SJ0101 (site | tree | core)
sj_tree <- rw_byTree(sj, snc =c(2,2,2), locname = 'SJ')
ca_tree <- rw_byTree(ca, snc =c(2,2,2), locname = 'CA')

sjL_tree <- rw_byTree(sjL, snc =c(2,2,2), locname = 'SJ')
sjH_tree <- rw_byTree(sjH, snc =c(2,2,2), locname = 'SJ')
caL_tree <- rw_byTree(caL, snc =c(2,2,2), locname = 'CA')
caH_tree <- rw_byTree(caH, snc =c(2,2,2), locname = 'CA')

# Si decido usar treeMean debería ser (solo un ejemplo)
# ids_sj <- read.ids(sj, stc = c(2, 2, 2))
# sj_meantree <- treeMean(sj, ids = ids_sj,  na.rm=TRUE)
```

* Crear diferentes dataset de diametro por sitio 
```{r}
# # function to subset averaged RW 
# subsetRW <- function(rwdf, codes){ 
#   require(dplyr)
#   aux_codes <- paste0('rw_', codes)
#   mysubset <- rwdf %>% dplyr::select(one_of(aux_codes), year)
#   mysubset
#   }

# diam <- ft %>% group_by(site) %>% do(data = (.)) %>% 
#              dplyr::select(data) %>% 
#              lapply(function(x) {(x)}) 


diam <- ft %>%
  mutate(diameter = dn_mm, 
         id = id_focalLoc) %>%
  dplyr::select(id, diameter, site) %>% 
  split(.$site) 


d_caH <- diam$CA_High[,c('id','diameter')]
d_caL <- diam$CA_Low[,c('id','diameter')]
d_sjH <- diam$SJ_High[,c('id','diameter')]
d_sjL <- diam$SJ_Low[,c('id','diameter')]

diamloc <- ft %>% 
  mutate(diameter = dn_mm, 
         id = id_focalLoc) %>%
  dplyr::select(id, diameter, loc) %>% split(.$loc) 

d_ca <- diamloc$CA[,c('id','diameter')]
d_sj <- diamloc$SJ[,c('id','diameter')]
```


# Cómputo del BAI por loc y/o site  

* He construido una funcion para el computo del BAI, teniendo en cuenta la aproximación de [@Piovesan2008]. Es similar a `bai.out`

```{r}
bai_sj <- bai_piovesan(rwdf = sj_tree, diam_df = d_sj)
bai_ca <- bai_piovesan(rwdf = ca_tree, diam_df = d_ca)

bai_sjH <- bai_piovesan(rwdf = sjH_tree, diam_df = d_sjH)
bai_sjL <- bai_piovesan(rwdf = sjL_tree, diam_df = d_sjL)
bai_caH <- bai_piovesan(rwdf = caH_tree, diam_df = d_caH)
bai_caL <- bai_piovesan(rwdf = caL_tree, diam_df = d_caL)

# bai_test <- round(bai.out(rwl = sj_tree, diam = d_sj), 4)
# test bai.out and bai_piovesan  
# unique(round(bai_sj$SJ03,4) == round(bai_test$SJ03,4))


# Set class to bai object 
# Esto es para que funcionen algunas otras funciones de dplR 
bais <- c('bai_sj', 'bai_ca', 'bai_sjH', 'bai_sjL', 'bai_caH', 'bai_caL')

for (i in bais){
  aux <- get(i)
  
  class(aux) <- c('rwl', 'data.frame')
  
  assign(i, aux)
}
  


```

# Cronologías by site / loc 


```{r}
# Robust mean biweith or not
cro_sjb <- chron(bai_sj, prefix = "SJ", biweight = TRUE)
cro_sjnotb <- chron(bai_sj, prefix = "SJ", biweight = FALSE)

cro_b <- cro_sjb %>% 
  mutate(year = as.numeric(rownames(.))) %>% 
  mutate(treatment = as.factor('biweight')) %>% 
  select(bai_mean = SJstd, samp.depth, year, treatment)

cro_notb <- cro_sjnotb %>% 
  mutate(year = as.numeric(rownames(.))) %>% 
  mutate(treatment = as.factor('biweight')) %>% 
  select(bai_mean = SJstd, samp.depth, year, treatment)


# Compute chronologies of BAI 


### Compute Chrono 

b <- bai_sj

chrono_bai <- function(bai_object){ 
  require(dplyr) 
  
  b <- bai_object 
  # alpha <- as.numeric(alpha)
  
  # Prepare data 
  b_aux <- b %>% 
  ##  Create a variable of year 
  mutate(year = as.numeric(rownames(.))) %>% 
  ## melt data 
  gather(series, bai, -year) %>% 
  # remove NA values 
  filter(bai != "") 
  
  # Compute mean, sd, se and sample deepth (n_trees)
  out <- b_aux %>% 
  group_by(year) %>% 
  summarise(bai_mean = mean(bai), 
            bai_sd = sd(bai), 
            bai_se = bai_sd / sqrt(n()), 
            n_trees = n()) %>% 
  as.data.frame()
  
  out 
} 


  # Loess 
  l <- loess(b_aux$bai ~ b_aux$year, span = alpha)
  years_v <- seq(min(b_aux$year), max(b_aux$year), 1)
  
  
  l_pred_aux <- predict(l, years_v, se=TRUE)
  l_pred <- as.data.frame(cbind(loess_fit = l_pred_aux$fit, 
                loess_se = l_pred_aux$se.fit,
                year = years_v))
  
  
  
  out <- out %>% inner_join(l_pred, by='year')
  
  out
}






cro_sj <- chrono_bai(bai_sj)
cro_sj$level <- 'SJ'
cro_ca <- chrono_bai(bai_ca)
cro_ca$level <- 'CA'


# San JUan 
cro_sjH <- chrono_bai(bai_sjH)
cro_sjH$site <- 'SJ_High'

cro_sjL <- chrono_bai(bai_sjL)
cro_sjL$site <- 'SJ_Low'

cro_sj<- rbind(cro_sjH, cro_sjL)
cro_sj$loc <- 'Norte (San Juan)'

cro %>% ggplot(aes(x=year, y=bai_mean/100, colour=site)) + 
  theme_bw() + ylab('BAI') + 
  geom_line() + geom_point() + scale_colour_manual(values = c("red", "blue")) + 
  theme(panel.grid = element_blank())



# Canar 
cro_caH <- chrono_bai(bai_caH)
cro_caH$site <- 'CA_High'
te <- chrono_bai(bai_caH)
plot.crn(te)
plot(te)
plot(te, add.spline=TRUE, nyrs=30)


cro_caL <- chrono_bai(bai_caL)
cro_caL$site <- 'CA_Low'

cro_ca <- rbind(cro_caH,cro_caL)
cro_ca$loc <- 'Sur (Canar)'

cro_ca %>% ggplot(aes(x=year, y=bai_mean/100, colour=site)) + 
  theme_bw() + ylab('BAI') + 
  geom_line() + geom_point() + scale_colour_manual(values = c("red", "blue")) + 
  theme(panel.grid = element_blank())


cro_sites <- rbind(cro_ca, cro_sj)

cro_sites %>% ggplot(aes(x=year, y=bai_mean/100, colour=site)) + 
  theme_bw() + ylab('BAI') + 
  geom_line() + geom_point() + 
  theme(panel.grid = element_blank()) + facet_wrap(~loc, nrow = 2) + 
  scale_colour_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a')) + 
  geom_smooth(method= 'loess', span = 0.75, se=FALSE)






 + 
geom_smooth(method= 'loess', span = 0.75, se=FALSE)


  geom_ribbon(aes(x= year, 
                  ymin = loess_fit - 1.96*loess_se,
                  ymax = loess_fit + 1.96*loess_se), na.rm = FALSE, 
              fill = "grey") +
c_sj 


c_sj %>% ggplot(aes(x=year, y=bai_mean)) + 
  theme_bw() + 
  geom_ribbon(aes(x= year, 
                  ymin = loess_fit - 1.96*loess_se,
                  ymax = loess_fit + 1.96*loess_se), na.rm = FALSE, 
              fill = "grey") +
  geom_line() + geom_point() + 
  geom_line() + geom_smooth(method= 'loess', span = 0.75, se=FALSE)






bb2 %>% ggplot(aes(x=year, y=bai_mean)) + 
  theme_bw() + 
  geom_ribbon(aes(x= year, 
                  ymin = bai_mean - bai_se,
                  ymax = bai_mean + bai_se), na.rm = FALSE, 
              fill = "grey") +
  geom_line() + geom_point() + 
  geom_smooth(method= 'loess', span = 0.30, se=FALSE)


# IC LOESS 



  
  
  geom_smooth(method= 'loess', span = 0.30, se=FALSE) + theme_bw() + 
  geom_bar(aes(x=year, stat = (samp.depth*10), colour=treatment))








# cc <- chrono_bai(bai_sj, prefix = "SJ")


chrono_bai <- function(bai_data, prefix){ 
  
    if (length(prefix) == 0) {
        prefix.str <- ""
    }
    else {
        prefix.str <- as.character(prefix)[1]
        if (is.na(prefix.str) || Encoding(prefix.str) == "bytes" || 
            nchar(prefix.str) > 3) {
            stop("'prefix' must be a character string with less than 4 characters")
        }
    }
    n_trees <- rowSums(!is.na(bai_data))
    
    out <- bai_data 
    
    
    out <- data.frame(samps)
    out
}
  
```


```{r}
# centred moved average smooth
# https://cran.r-project.org/web/packages/smooth/vignettes/sma.html



correla_cronos <- function(cronologia, win_vector, crononame){
  
  cro_object <- cronologia 
  
  # Set bai and years variables 
  bai <- cro_object[,'bai_mean']
  yearss <- cro_object[,'year']
  
  # object to store 
  out <- c() 
  
  for (i in seq_along(win_vector)){ 
    # moving window size 
    f <- rep(1/i, i)
    
    # moving average smooth 
    bai_smooth <- stats::filter(bai, f, sides=1)
    
    # out 
    out_aux <- as.data.frame(cbind(yearss, bai_smooth))
    
    out_aux$size_wind <- i
    out <- rbind(out, out_aux)
  }
  out$crononame <- crononame 
  out
} 


correla_cro_caH <- correla_cronos(cro_caH, win_vector=seq(1,40, by=1), crononame = 'cro_caH')
correla_cro_caL <- correla_cronos(cro_caL, win_vector=seq(1,40, by=1), crononame = 'cro_caL')
correla_cro_sjH <- correla_cronos(cro_sjH, win_vector=seq(1,40, by=1), crononame = 'cro_sjH')
correla_cro_sjL <- correla_cronos(cro_sjL, win_vector=seq(1,40, by=1), crononame = 'cro_sjL')

correla_croSJ <- rbind(correla_cro_sjH, correla_cro_sjL)



# SJ 
out_final <- c() 

for (j in 1:40){
  
  aux <- correla_croSJ %>% 
    filter(size_wind == j) %>%
    select(-size_wind) %>% 
    spread(crononame, bai_smooth) %>% 
    as.data.frame() 
  
  rownames(aux) <- aux$yearss 
  aux1 <- aux[,-1]
  
  output_correla <- interseries.cor(aux1) 
  
  out <- as.data.frame(cbind(res.cor = output_correla$res.cor[1], 
                           p_val = output_correla$p.val[1])) 
  
  out$size <- j 
  
  out_final <- rbind(out_final, out) 
  
  } 


out_final$site <- 'SJ'

correla_final_sj <- out_final



# CA
correla_croCA <- rbind(correla_cro_caH, correla_cro_caL)
out_final <- c() 

for (j in 1:40){
  
  aux <- correla_croCA %>% 
    filter(size_wind == j) %>%
    select(-size_wind) %>% 
    spread(crononame, bai_smooth) %>% 
    as.data.frame() 
  
  rownames(aux) <- aux$yearss 
  aux1 <- aux[,-1]
  
  output_correla <- interseries.cor(aux1) 
  
  out <- as.data.frame(cbind(res.cor = output_correla$res.cor[1], 
                           p_val = output_correla$p.val[1])) 
  
  out$size <- j 
  
  out_final <- rbind(out_final, out) 
  
  } 


out_final$site <- 'CA'

correla_final_ca <- out_final



correla_finales <- rbind(correla_final_ca, correla_final_sj)
correla_finales %>% 
  ggplot(aes(x=size, y=res.cor, colour=site)) + geom_line()+
  theme_bw() + 
  ylab('Correlation coefficient') + xlab('years(smooth)') + geom_smooth(method = 'loess', se=FALSE)













c11 <- c1[26:nrow(c1),]


cor(c11$cro_sjH, c11$cro_sjL)



ggplot(c1, aes(x=yearss, y=cro_sjH)) + geom_line() + 
  geom_line(aes(x=yearss, y=cro_sjL), colour='blue')
  





cronologia <- cro_caH
cro_object <- get()
cro_object <- get(cronologia)
  
  
  
  

  
  
plot(cro_caH$year, cro_caH$bai_mean, type='l')
lines(cro_caH$year, y_lag, col="blue")
  
  
  y_lag <- filter(y, f20, sides=1)
lines(x, y_lag, col="red")


# average of current sample and 19 previous samples (red)
f20 <- rep(1/20, 20)
f20
#>  [1] 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05
#> [18] 0.05 0.05 0.05







```{r}




# SJ 

cro_sj <- chron(bai_sj, prefix = "SJ", biweight = TRUE)
cro_sj %>% plot(add.spline=TRUE, nyrs=30)


cro_ca <- chron(bai_ca, prefix = "CA", biweight = TRUE)
cro_ca %>% plot(add.spline=TRUE, nyrs=30)



cro_ca2 <- cro_ca %>% 
  mutate(year = as.numeric(rownames(.))) %>% 
  mutate(treatment = as.factor('CA')) %>% 
  select(bai_mean = CAstd, samp.depth, year, treatment)


cro_sj2 <- cro_sj %>% 
  mutate(year = as.numeric(rownames(.))) %>% 
  mutate(treatment = as.factor('SJ')) %>% 
  select(bai_mean = SJstd, samp.depth, year, treatment)


cro2 <- rbind(cro_ca2, cro_sj2)

cro2 %>% ggplot(aes(x=year, y=bai_mean, colour=treatment)) + 
  geom_line() + geom_smooth(method= 'loess', span = 0.30, se=FALSE) + theme_bw() + 
  geom_bar(aes(x=year, stat = (samp.depth*10), colour=treatment))


  geom_point(aes(x=year, y = samp.depth*100)) 





cro_ca2 %>% ggplot(aes(x=year, y=bai_mean)) + 
  geom_line(colour='gray') + geom_smooth(method= 'loess', span = 0.80, se=FALSE) + theme_bw() 
+
  geom


plot()


str(cro_ca)



names(cro_ca)









cro_ca <- chron(bai_ca, prefix = "CA", biweight = TRUE)
plot(cro_sjb, add.spline=TRUE, nyrs=30)









cro_sj <- chron(bai_sj, prefix = "SJ", biweight = FALSE)

cc <- cbind(cro_sj, cro_sjb)



su

```


---> VAS por AQUI 


```























## San Juan Data 

Algunos árboles tienen 3 cores. Sin embargo, no los tres cores llegan hasta la corteza, por lo tanto, no podemos utilizar el diametro para estimar bai. Vamos a realizar lo siguiente: 

* Crear dos datasets: 
    * Dataset con series de datos que llegan hasta corteza (`sj_cor`)
    * Dataset con series de datos que no llegan hasta corteza (`sj_sin`): se trata de cores que no llegan hasta la corteza. 
    
* Para el cálculo del BAI, en el dataset `sj` utilizamos el diámetro medido en campo. En el caso del dataset `sj_sin` utilizamos la suma de todos los diámetros (:red_circle: `$TODO$ ASK to Guillermo`)

```{r}
# Get summary ring-width series
sj_summ <- summary(sj)

# Get names cores with last year different to 2016 
id_cores_no_bark <- sj_summ %>% 
  filter(last != 2016) %>% select(series) %>% mutate(series = factor(series)) 

id_cores_no_bark <- unname(unlist(id_cores_no_bark))

# Subbet datasets 
sj_cor <- sj[which(! colnames(sj) %in% (id_cores_no_bark))]
sj_sin <- sj[which(colnames(sj) %in% (id_cores_no_bark))]
```


Lectura y preparación de datos de diámetro

```{r}
compete <- read.csv(file=paste0(di, '/data_raw/dendro_competence.csv'), header=TRUE, sep=',')

# Compute diameter (mm)
compete <- compete %>% 
  mutate(dn_mm = (perim_mm / pi))
         
# Get only focal trees, and only selected variables 
ft <- compete %>% 
  filter(sp=='Focal') %>% 
  filter(id_focal!='Fresno') %>% 
  select(id_focal, loc, dn_mm, height_cm)

# Select only SJ trees and 
ft_sj <- ft %>% filter(loc=='SJ')


# get Create a dataframe with core ID
cores <- data.frame(id_cores=colnames(sj))

# Extract replicate and Tree ID from core ID 
cores <- cores %>% 
  mutate(id_focal = as.factor(stringr::str_sub(id_cores, 3,5)),
         id_replica = stringr::str_sub(id_cores, 6,8))

# Create df with diameter and height for each core ID 
diam_cores <- cores %>% inner_join(ft_sj, by='id_focal') %>% 
  select(id_cores, dn_mm)

# remove diamm of cores without bark 
diam_cores_sj <- diam_cores %>% filter(! id_cores %in% id_cores_no_bark)
```


```{r}
rwl.report(sj_cor)






bai_p <- bai_piovesan(rwdf = sj_cor, diam_df = diam_cores_sj)
bai_d <- bai.out(rwl = sj_cor, diam = diam_cores_sj)







diam_cores_sjsin <- data.frame(id_cores = colnames(sj_sin),
                               dn_mm = colSums(sj_sin, na.rm = TRUE))
rownames(diam_cores_sjsin) <- NULL


bai_psin <- bai_piovesan(rwdf = sj_sin, diam_df = diam_cores_sjsin)
bai_dsinsin <- bai.out(rwl = sj_sin)
bai_dsin <- bai.out(rwl = sj_sin, diam = diam_cores_sjsin)





```

```{r}
set.seed(1234)
serie <- sample(colnames(b_test_dplR),1)

require(reshape2)


bp <- melt(t(b_test_piovesan))
names(bp) <- c('cores', 'years', 'bai_p') 


bd <- melt(t(b_test_dplR))
names(bd) <- c('cores', 'years', 'bai_d') 




diff <- bp %>% 
  inner_join(bd, by=c('cores','years')) %>% 
  mutate(diff = bai_p - bai_d)




ggplot(x, aes(y=bai, x=years, colour=test)) + 
  geom_point() + 
  facet_wrap(~cores)











```{r, eval=FALSE, echo=FALSE}
# BAI dplR
baisj <- bai.out(rwl = sj_cor, diam = diam_cores_sj)

baisjt <- bai.out(rwl = sjt)


# Function to compute BAI (Piovesan et al)

# rwl_file
myrwl <- sj_cor
# Diameter df  
diam_df <- diam_cores_sj

# Core
id_core <- 'SNA0101'  

# Ring-width serie
myrwl_serie <- myrwl[[id_core]]

# Diameter for core id_core 
dbh <- subset(diam_df, id_cores == id_core)
dbh <- dbh[,2]



myrwl_serie2 <- na.omit(myrwl_serie)
cum



r0 <- dbh/2 - c(0,cumsum(rev(myrwl_serie2)))



bai <- (pi/4)*(dbh^2 - ((dbh - 2*myrwl_serie)^2)) 

s <- myrwl_serie[94:96]

d <- sum(s)*2












########## test Piovesan
# rwl_file
myrwl <- baisj

#id_core


# Extract rwl serie 
myrwl_i <- myrwl[[1]]


dbh <- 372.4226





# Year
n.vec <- seq_len(nrow(myrwl))

# Series
seq_len(ncol(myrwl))

# Select a ring-width series
dat <- myrwl[[1]] 
# Remove NA
dat2 <- na.omit(dat)


ggplot(s1, aes(y=SNA0101, x=row.names(s1))) + 
  geom_point() + 
  geom_line(b1, aes(y=SNA0101, x=row.names(b1)))

ggplot(s1, aes(y=SNA0101, x=row.names(b1), group=1)) + geom_line()


```




```{r}

x <- c(1,2,2,3,1,3,4,5)

xx <- rollmean(x=x, k=3, align = 'center', na.pad = T)

```


```{r}
# tes plots 


rownames(sj_tree) <- sj_tree$year
sj_tree <- sj_tree[,-1]
carwi <- detrend(rwl = ca_tree, method = "ModNegExp")
ca_prwi <- data.frame(rw = rowMeans(carwi, na.rm=TRUE))
ca_prwi <- ca_prwi %>% mutate(year = rownames(.),
                        site = as.factor('ca'),
                        rw_log = log(rw))



xx <- data.frame(rw = rowMeans(ca_tree, na.rm=TRUE))

plot(xx$rw~rownames(xx))

sjcrn <- chron(sjrwi, prefix = "rw_")
plot(sjcrn, add.spline=TRUE, nyrs=20)
plot()


sj_tree <- rw_byTree(sj)
ca_tree <- rw_byTree(ca)

rownames(ca_tree) <- ca_tree$year
ca_tree <- ca_tree[,-1]
ca_p <- data.frame(rw = rowMeans(ca_tree, na.rm=TRUE))

ca_p <- ca_p %>% mutate(year = rownames(.),
                        site = as.factor('ca'),
                        rw_log = log(rw))

rownames(sj_tree) <- sj_tree$year
sj_tree <- sj_tree[,-1]
sj_p <- data.frame(rw = rowMeans(sj_tree, na.rm=TRUE))

sj_p <- sj_p %>% mutate(year = rownames(.),
                        site = as.factor('sj'),
                        rw_log = log(rw))

xx <- rbind(ca_p, sj_p)


xx %>% ggplot(aes(x=as.Date(year, format='%Y'), y=rw_log)) + 
  geom_line(aes(group=1)) + 
  scale_x_date(date_labels = "%Y") + 
  facet_wrap(~site, ncol=1, scales = 'free_y') + 
  theme_bw() + 
  geom_vline(xintercept = as.numeric(as.Date(c('2005-06-01')))) +
  geom_vline(xintercept = as.numeric(as.Date(c('2012-06-01')))) +
  xlab('Year') + ylab('Ring width (1/100 mm)')
  
xx %>% filter(site =='ca') %>% 
  ggplot(aes(x=as.Date(year, format='%Y'), y=rw)) + geom_point(colour='blue') +
  geom_line(aes(group=1), colour='blue') + 
  scale_x_date(date_labels = "%Y") + 
  theme_bw() + 
  # geom_vline(xintercept = as.numeric(as.Date(c('2005-06-01')))) +
  # geom_vline(xintercept = as.numeric(as.Date(c('2012-06-01')))) +
  xlab('Year') + ylab('Ring width (1/100 mm)')
  

ca_prwi %>%
  ggplot(aes(x = as.Date(year, format = '%Y'), y = rw)) + geom_point() +
  geom_line(aes(group = 1)) +
  scale_x_date(date_labels = "%Y") +
  theme_bw() +
  # geom_vline(xintercept = as.numeric(as.Date(c('2005-06-01')))) +
  # geom_vline(xintercept = as.numeric(as.Date(c('2012-06-01')))) +
  xlab('Year') + ylab('Ring width Index')
  
```
